export interface IReadable<T = any> {
    [Symbol.iterator](): any;
    [Symbol.asyncIterator](): any;
    read(): Promise<T | undefined>;
}
export declare class ReadableIterator<T = any> implements Iterator<Promise<T>> {
    private readonly readable;
    constructor(readable: IReadable<T>);
    next(): IteratorResult<Promise<T>>;
}
export declare class ReadableAsyncIterator<T = any> implements AsyncIterator<T> {
    private readonly readable;
    constructor(readable: IReadable<T>);
    next(): Promise<IteratorResult<T>>;
}
export declare class Readable<T = any> implements IReadable<T> {
    private readonly reader;
    [Symbol.iterator](): any;
    [Symbol.asyncIterator](): any;
    constructor(reader: IReadable<T>);
    /** Reads the next value from this channel or `undefined` if eof. */
    read(): Promise<T | undefined>;
}
export interface IWritable<T = any> {
    /** Writes data to the channel. */
    write(data: T): Promise<void>;
    /** Ends this channel. */
    end(): Promise<void>;
}
export declare class Writable<T = any> implements IWritable<T> {
    private writer;
    constructor(writer: IWritable<T>);
    /** Writes data to the channel. */
    write(data: T): Promise<void>;
    /** Ends this channel. */
    end(): Promise<void>;
}
/**
 * Stream<T>
 *
 * An in-memory asynchronous stream of values. Implements both
 * IReadable<T> and IWritable<T> interfaces and is used as a back
 * plane for in memory channels.
 */
export declare class Stream<T = any> implements IReadable<T>, IWritable<T> {
    private bounds;
    [Symbol.iterator](): any;
    [Symbol.asyncIterator](): any;
    private writers;
    private sinks;
    private queue;
    constructor(bounds?: number);
    /** Writes data to the channel. */
    write(value: T): Promise<void>;
    /** Ends this stream. */
    end(): Promise<void>;
    /** Reads the next value from this channel or `undefined` if eof. */
    read(): Promise<T>;
    private writePause;
    private writeResume;
    private readPause;
    private readResume;
}
/**
 * Selects from the given IReadable<T> types and produces a
 * new multiplexed IReadable<T> merging elements for each.
 */
export declare function select<T1, T2, T3, T4, T5, T6, T7, T8>(r1: IReadable<T1>, r2: IReadable<T2>, r3: IReadable<T3>, r4: IReadable<T4>, r5: IReadable<T5>, r6: IReadable<T6>, r7: IReadable<T7>, r8: IReadable<T8>): IReadable<T1 | T2 | T3 | T4 | T5 | T6 | T7>;
/**
 * Selects from the given IReadable<T> types and produces a
 * new multiplexed IReadable<T> merging elements for each.
 */
export declare function select<T1, T2, T3, T4, T5, T6, T7>(r1: IReadable<T1>, r2: IReadable<T2>, r3: IReadable<T3>, r4: IReadable<T4>, r5: IReadable<T5>, r6: IReadable<T6>, r7: IReadable<T7>): IReadable<T1 | T2 | T3 | T4 | T5 | T6 | T7>;
/**
 * Selects from the given IReadable<T> types and produces a
 * new multiplexed IReadable<T> merging elements for each.
 */
export declare function select<T1, T2, T3, T4, T5, T6>(r1: IReadable<T1>, r2: IReadable<T2>, r3: IReadable<T3>, r4: IReadable<T4>, r5: IReadable<T5>, r6: IReadable<T6>): IReadable<T1 | T2 | T3 | T4 | T5 | T6>;
/**
 * Selects from the given IReadable<T> types and produces a
 * new multiplexed IReadable<T> merging elements for each.
 */
export declare function select<T1, T2, T3, T4, T5>(r1: IReadable<T1>, r2: IReadable<T2>, r3: IReadable<T3>, r4: IReadable<T4>, r5: IReadable<T5>): IReadable<T1 | T2 | T3 | T4 | T5>;
/**
 * Selects from the given IReadable<T> types and produces a
 * new multiplexed IReadable<T> merging elements for each.
 */
export declare function select<T1, T2, T3, T4>(r1: IReadable<T1>, r2: IReadable<T2>, r3: IReadable<T3>, r4: IReadable<T4>): IReadable<T1 | T2 | T3 | T4>;
/**
 * Selects from the given IReadable<T> types and produces a
 * new multiplexed IReadable<T> merging elements for each.
 */
export declare function select<T1, T2, T3>(r1: IReadable<T1>, r2: IReadable<T2>, r3: IReadable<T3>): IReadable<T1 | T2 | T3>;
/**
 * Selects from the given IReadable<T> types and produces a multiplexed
 * IReadable<T> combining elements for each.
 */
export declare function select<T1, T2>(r1: IReadable<T1>, r2: IReadable<T2>): IReadable<T1 | T2>;
/**
 * Selects from the given IReadable<T> types and produces a
 * new multiplexed IReadable<T> merging elements for each.
 */
export declare function select<T1>(r1: IReadable<T1>): IReadable<T1>;
export interface IChannel<T = any> {
    readable: IReadable<T>;
    writable: IWritable<T>;
}
/** Creates a channel with optional buffering bounds. (default is Number.MAX_SAFE_INTEGER) */
export declare function channel<T = any>(bound?: number): IChannel<T>;
